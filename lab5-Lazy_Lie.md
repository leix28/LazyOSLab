# Lab5 report

## [练习一]

**设计实现**

- 修改`alloc_proc`中的初始化，增加wait_state, cptr, yptr, optr。
- 根据注释填写`load_icode`，其中包括初始化cs, ds, es, ss, esp, eip, eflags。
	- 将代码段寄存器置为USER_CS，数据段、附加段、堆栈段都置为USER_DS。
	- 将堆栈寄存器置为USTACKTOP。
	- 基地址指针置为ELF中的入口地址e_entry。
	- 用户态程序应当允许中断，所以需要在eflags中进行设置。
	
**当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。**

在用户态进程创建时，已经设置好了trapframe中的信息，在时钟中断处理schedule时，如果分配到这个程序执行，那么将trapframe中保存的内容恢复到相关寄存器，用户进程就开始执行了。


## [练习二]

**设计实现**

根据注释实现，获取源地址、目标地址的内核虚地址，然后使用memcpy进行拷贝，最后用page_insert修改页表。

## [练习三]

**对 fork/exec/wait/exit函数的分析**

- 在fork中，需要先产生一个新的进程，完成内存的建立和拷贝。然后，将进程放入链表等待被调度。
- exec将目标程序直接加载执行。
- wait在子进程尚未完成时，标明等待，然后让出资源。
- exit结束执行，释放资源。

**给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。**

```
load_icode() ----> do_fork() ----> do_exit()
              ^|-> do_wait()   |
              ||-> do_yield()  |
              |________________|
```



